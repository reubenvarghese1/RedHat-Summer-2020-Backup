WIP Changes made:

- Depmod_load_single_Module : This function essentially is to add a single depmod module instead of having to search all the directories like depmod -a does. Logic for loading details from existing output files to be written.
https://github.com/reubenvarghese1/RedHat-Summer-2020-Backup/blob/0b731190f5db21b67d16fd962408a013351dbdef/Code/Kmod/source/kmod/tools/depmod.c#L2607

- Depmod_remove_single_module : Removes a single module should we figure that this module is not compatible when loading. By this time, none of the output files have yet been overwritten. Similar to depmod_del_module but not the same. 
https://github.com/reubenvarghese1/RedHat-Summer-2020-Backup/blob/0b731190f5db21b67d16fd962408a013351dbdef/Code/Kmod/source/kmod/tools/depmod.c#L2607

- Depmod_determine_if_compatible: Checks if module with name exists in hash and then tries to load it, if not then it returns an error.
https://github.com/reubenvarghese1/RedHat-Summer-2020-Backup/blob/0b731190f5db21b67d16fd962408a013351dbdef/Code/Kmod/source/kmod/tools/depmod.c#L2668

- Depmod_symbol_remove : Essentially removes a symbol. This is to remove all the symbols of an incompatible module.
https://github.com/reubenvarghese1/RedHat-Summer-2020-Backup/blob/0b731190f5db21b67d16fd962408a013351dbdef/Code/Kmod/source/kmod/tools/depmod.c#L1473

- Module should not load if dependency loading fails. Not sure if this is intended but I feel it makes sense. That being said, if modules are loaded even in cases when dependencies are not met then due to crc issues, then we could introduce a new cfg parameter called strict_check to prevent the loading if any dependency isnt loaded etc.
https://github.com/reubenvarghese1/RedHat-Summer-2020-Backup/blob/0b731190f5db21b67d16fd962408a013351dbdef/Code/Kmod/source/kmod/tools/depmod.c#L1641

List of changes to be discussed:

- Move from storing hash of symbols with symbol name as key to making the crc key. Because from my understanding symbols with duplicate names may exist but crc will be unique.


- Initially detect cycles used to just throw a warning as shown here https://github.com/lucasdemarchi/kmod/blob/650f89cd2510820a71dfc1b004634a309f12ecf1/tools/depmod.c#L1659 . Later, it was pointed out that developers would have to check the logs each time to realize that there is a cycle. This however, should not be a warning but an error. Hence, later it was changed to an error. Similarly, it is worth debating that https://github.com/lucasdemarchi/kmod/blob/650f89cd2510820a71dfc1b004634a309f12ecf1/tools/depmod.c#L1534 should also throw an error instead of just a warning since the module which requires this dependency will surely not work if this is not right. Another suggestion would be to check if the dependency is being found for a single module or as part of depmod -a. If for a single module then probably throw an error to prevent installation.

- Determine what kind of refactoring would be needed(as suggested by Stanislav). Submit that to upstream. Then, slowly keep adding to it and extending the functionality instead of submitting a bunch of changes all at once.

- Instead of creating symlinks to the modules like weak modules does, Stanislav mentioned that we could somehow do away with it. Thinking about it, I think, we can modify the add single module function to work such that when finds a module, it will also check all kernels and if the current module is compatible with that one, then it will add this module path to that kernel version's modules.dep etc. Such that when the user runs modprobe from that kernel, it will automatically use the path given in the modules.dep and load the module from the other kernel directory instead of loading it using the symlink. Now while this may sound simple, this requires us to create a robust interface for adding a single module(currently depmod just works using depmod -a i.e. search all directories, generate the dependency graph each time). If we can somehow just skip the need for doing that each time then it would help reduce the time by a lot. Maybe create a flag that just helps it install one module.
Similarly also create add kernel and other functions like weak modules. How we exactly go about doing this is the main task that would require some brainstorming. Intitially while making these changes during the summer, I thought of letting depmod do its usual thing of searching all directories, creating a dependency graph each time. But the more I think about it, I feel this should be done away with. For ex, while adding a new kernel, it makes sense to go through all folders, build the graph etc but if we just want to add a module, we should try to figure out a way by which we can skip some of these steps. Otherwise, just imagine a user installs a bunch of rpms. If they have multiple kernels and each kernel having around 600-700 modules installed. This seemingly simple task of installing a single module will suddenly take a lot of time. 

	- One simple idea would have also have been to set external * /lib/modules/(the directory where all kernels are stored) in the config file. This would essentially ensure that all the directories are searched for each kernel version. This would take care of adding out-of-tree-modules but then uninstalling a module is what we would have to focus on. Moreover, again even in this case, if we say just want to install one new module. Doing depmod -a after the installation will cause it to look into all these directories all over again which in my opinion would be very costly. Hence, we while the external keyword surely is a good start, we have to come up with an approach to reduce the time taken for adding a single module i.e. depmod should be able to build upon the existing info it has from the files it generated instead of generating a graph all over. Now the -A flag initially seems like a good idea but then again it just checks if there are any updates which will be made to the modules.dep file. This is surely going to be the case when adding a new module but the task is to add a module without regenerating from scratch.

- All in all, while the summer may not have produced a lot of output that goes into production, it has put me in a good position to be able to get right into the code upon resuming in Jan since I was able to try out a bunch of changes within depmod and look at how everything works. Can't wait to get back to this in Jan!
